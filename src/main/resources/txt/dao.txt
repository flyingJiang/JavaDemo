--技术
ORM 框架，并不是只有 MyBatis 一家！
只是说 MyBatis 在国内使用的标胶广泛，大概占据中国市场的90%以上。
国外用的最多的是Hibernate。
 
至于其中的原因，MyBatis 和 Hibernate 之间的区别等等。。。
包括 在 Hibernate 之后，又有一个 Spring JPA，与其又有和区别？
等 MyBatis 讲完之后，再给你们讲。

----
@Param 注解 和 @RequestParam 注解，起着相同的作用。
方法 参数重命名。一旦重命名之后，原来的名称是不能使用的。

只不过 @Param 注解中的参数是 重命名后的结果。
而 @RequestParam 注解中的参数 是参数原名，方法参数是 重命名的结果。

----
useGeneratedKeys：
这会令 MyBatis 使⽤ JDBC 的 getGeneratedKeys ⽅法来取出由数据库内部⽣成的主键
（⽐如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的⾃动递增字段），默认值：false。
 
keyColumn：
设置⽣成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第⼀列的时候，是必须设置的。如果⽣成列不⽌⼀个，可以⽤逗号分隔多个属性名称。
 
keyProperty：
指定能够唯⼀识别对象的属性，MyBatis 会使⽤ getGeneratedKeys 的返回值 或 insert 语句的 selectKey ⼦元素设置它的值，默认值：未设置（unset）。如果⽣成列不⽌⼀个，可以⽤逗号分隔多个属性名称。
 
简单来说：我们加上 keyColumn 的原因，就是为了确保获取 对应字段。

-----
#{}：预编译处理。
${}：字符直接替换

预编译处理是指：MyBatis 在处理#{}时，会将 SQL 中的 #{} 替换为?号，使⽤ PreparedStatement 的 set ⽅法来赋值。直接替换：
而MyBatis 在处理 ${} 时，就是把 ${} 直接替换成变量的值。
————————————————
使用concat拼接方法，就可以解决问题了。

#{} 和 ${} 的区别总结
1、定义不同：#{} 预处理：而 ${} 是直接替换
 
2、使用不同：#{} 适用于所有类型的参数匹配；但 ${} 只适用于数值类型。
 
3、安全性不同：#{} 性能高，并且没有安全问题；但 $ {} 存在 SQL 注入的安全问题。
 
4、使用场景不同：
当传递的是一个 SQL 关键字 的时候，只能 使用 ${} 。
当传递的是一个字段，总之，就是需要获取到参数类型 与 内容，只能使用 #{}。
（PS：数字类型，#{} 和 ${} 都是可以使用的！）
 
5、 ${} 不能用于 模糊匹配查询；而 #{} 需要搭配 concat 才能在模糊匹配中使用。
————————————————
resultType && resultMap 的区别
1、在对象属性名称 与 数据表字段名称，相同的情况下：
使用 resultType 比 resultMap 更爽！
 
2、在对象属性名称 与 数据表字段名称，不同的情况下：
使用 resultMap 可以指定 不同名称的 字段与属性 的映射关系。
————————————————

